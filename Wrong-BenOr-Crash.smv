-- Running the Model in NuXmv:
--  Download NuXmv (https://nuxmv.fbk.eu/download.html) and place the current file (Wrong-BenOr-Crash.smv) 
--  in the same folder as the NuXmv executable. Then go to the terminal and change directory to this
--  folder and execute in steps:
--     (1) "./nuXmv -int Wrong-BenOr-Crash.smv" (starts NuXmv in interactive mode with the model file)
--     (2) "go_msat" (inside the NuXmv shell, enable the IC3 engine)
--     (3) "check_ltlspec_ic3" (checks all the LTL specifications using IC3)

--==============================================================================
-- Protocol A (Ben-Or, 1983): https://dl.acm.org/doi/pdf/10.1145/800221.806707
-- Model is same as Ben-Or Crash except resilence condition 2t < n is dropped
-- Phase order (per round): Initial -> Promise -> (Decide | Initial of next round)
--==============================================================================


MODULE main

-- parameter counters, they are frozen as they donâ€™t change under transitions

FROZENVAR
  n : integer;     -- # processes 
  t : integer;     -- crash threshold


-- Per round location counters

VAR
  s0  : integer;     -- # processes starting round 0 with value 0
  s1  : integer;     -- # processes starting round 0 with value 1
  i0  : integer;     -- # processes proposing 0 
  i1  : integer;     -- # processes proposing 1 
  p0  : integer;     -- # processes promising 0
  p1  : integer;     -- # processes promising 1
  px  : integer;     -- # processes promising X (undecided)
  d0  : integer;     -- # processes decided 0 
  d1  : integer;     -- # processes decided 1 


-- Per round message counters

VAR
  mi0 : integer;     -- # broadcasts of 0 in Initial phase
  mi1 : integer;     -- # broadcasts of 1 in Initial phase
  mp0 : integer;     -- # broadcasts of promise-0
  mp1 : integer;     -- # broadcasts of promise-1
  mpx : integer;     -- # broadcasts of promise-X


-- History record counters

VAR
  Rs0    : integer;  -- cumulative (across all rounds) counts of # of visits to s0
  Rs1    : integer;  -- cumulative counts of # of visits to s1
  Rd0    : integer;  -- cumulative counts of # of visits to d0
  Rd1    : integer;  -- cumulative counts of # of visits to d1
  Rfail  : integer;  -- cumulative counts of # of crashed processes


-- Initially:
--  (1) Resilience condition dropped.
--  (2) All processes start in the initial control locations (s0, s1).
--  (3) All message counters are 0.
--  (4) History counters match the corresponding location counters.

INIT
  n > 0 & t >= 0 &

  s0 >= 0 & s1 >= 0 & s0 + s1 = n &
  i0 = 0 & i1 = 0 &
  p0 = 0 & p1 = 0 & px = 0 &
  d0 = 0 & d1 = 0 &

  mi0 = 0 & mi1 = 0 &
  mp0 = 0 & mp1 = 0 & mpx = 0 &

  Rs0 = s0 & Rs1 = s1 & 
  Rd0 = 0 & Rd1 = 0 & 
  Rfail = 0;

-- Macro Update Transitions:
-- In each phase, the only transition is a jump to the next phase.
-- All non-crashed processes perform this jump synchronously.
-- A process that does not jump in the synchronous step is counted as crashed.
-- We use three macro jump transitions: Start -> Initial, Initial -> Promise, Promise -> (Initial | Decide).

-- Before specifying transitions we define the upward closure of guards g1-g8 (see RPT syntax on top)
 
DEFINE Q := n - t;

DEFINE 
  g1c := (mi0 + mi1 >= Q) & (2*mi0 > n);
  g2c := (mi0 + mi1 >= Q) & (2*mi1 > n);
  g3c := (mi0 + mi1 >= Q) & (2*mi0 >= Q - t) & (2*mi1 >= Q - t);
  g4c := (mp0 + mp1 + mpx >= Q) & (mp0 > t);
  g5c := (mp0 + mp1 + mpx >= Q) & (mp1 > t);
  g6c := (mp0 + mp1 + mpx >= Q) & (mp1 + mpx >= Q - t) & (mp0 + mpx >= Q - t) & (mpx >= Q - 2*t) & (mp0 > 0);
  g7c := (mp0 + mp1 + mpx >= Q) & (mp1 + mpx >= Q - t) & (mp0 + mpx >= Q - t) & (mpx >= Q - 2*t) & (mp1 > 0);
  g8c := mpx >= Q;

TRANS
  ( -- Start -> Initial, enabled if current round is start phase i.e. s0 + s1 > 0
    s0 + s1 > 0 & 
    
    -- reset and update location counters
    next(i0) >= 0 & next(i1) >= 0 & next(i0) <= s0 & next(i1) <= s1 &
    next(p0) = 0 & next(p1) = 0 & next(px) = 0 & 
    next(s0) = 0 & next(s1) = 0 &
    next(d0) = 0 & next(d1) = 0 & 

    -- reset and update message counters
    next(mi0) = next(i0) & next(mi1) = next(i1) &
    next(mp0) = 0 & next(mp1) = 0 & next(mpx) = 0 &

    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 &
    next(Rd0) = Rd0 & next(Rd1) = Rd1 &
    next(Rfail) >= 0 & next(Rfail) <= t &
    next(Rfail) = Rfail + s0 + s1 - (next(i0) + next(i1))
    

  )
  |
  (
    -- Initial -> Promise, enabled if current round is a initial phase i.e. i0 + i1 > 0
    i0 + i1 > 0 &

    -- reset and update location counters
    next(p0) >= 0 & next(p1) >= 0 & next(px) >= 0 &
    next(p0) + next(p1) + next(px) <= i0 + i1 &
    next(i0) = 0 & next(i1) = 0 & 
    next(d0) = 0 & next(d1) = 0 & 
    next(s0) = 0 & next(s1) = 0 & 
    
    -- if some process is moving to location l then then upward closure of some guard targeting l must hold
    ((next(p0) > 0) -> g1c) & 
    ((next(p1) > 0) -> g2c) & 
    ((next(px) > 0) -> g3c) &

    -- reset and update message counters
    next(mp0) = next(p0) & next(mp1) = next(p1) & next(mpx) = next(px) & 
    next(mi0) = 0 & next(mi1) = 0 &
    
    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 &
    next(Rd0) = Rd0 & next(Rd1) = Rd1 &
    next(Rfail) >= Rfail & next(Rfail) <= t &
    next(Rfail) = Rfail + i0 + i1 - (next(p0) + next(p1) + next(px))

  )
  | 
  ( -- Promise -> Initial/Decide, enabled if current round is a promise phase i.e. p0 + p1 + px > 0
    p0 + p1 + px > 0 &

    -- reset and update location counters
    next(d0) + next(d1) + next(i0) + next(i1) <= p0 + p1 + px &
    next(d0) >= 0 & next(d1) >= 0 & next(i0) >= 0 & next(i1) >= 0 &
    next(p0) = 0 & next(p1) = 0 & next(px) = 0 & 
    next(s0) = 0 & next(s1) = 0 &

    -- if some process is moving to location l then then upward closure of some guard targeting l must hold
    ((next(d0) > 0) -> g4c) & 
    ((next(d1) > 0) -> g5c) & 
    ((next(i0) > 0) -> (g6c | g8c)) & 
    ((next(i1) > 0) -> (g7c | g8c)) &

    -- reset and update message counters
    next(mi0) = next(i0) & next(mi1) = next(i1) &
    next(mp0) = 0 & next(mp1) = 0 & next(mpx) = 0 &
    
    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 &    
    next(Rd0) = Rd0 + next(d0) & next(Rd1) = Rd1 + next(d1) &
    next(Rfail) >= Rfail & next(Rfail) <= t &
    next(Rfail) = Rfail + p0 + p1 + px - (next(d0) + next(d1) + next(i0) + next(i1))

  );


-- LTL Specifications (none satisfied, outputs counterexample)

-- Agreement
LTLSPEC G(Rd0 <= 0) | G(Rd1 <= 0); 

-- Validity
LTLSPEC (Rs0 <= 0 -> G(Rd0 <= 0)) & (Rs1 <= 0 -> G(Rd1 <= 0)); 

-- Restricted-Termination
LTLSPEC F(Rd0 + Rd1 > 0) -> F(Rd0 + Rd1 + Rfail > n - 1);

-- Termination
LTLSPEC (F(Rd0 + Rd1 + Rfail  > n - 1));
