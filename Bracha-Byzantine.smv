-- Running the Model in NuXmv:
--  Download NuXmv (https://nuxmv.fbk.eu/download.html) and place the current file (Bracha-Byzantine.smv) 
--  in the same folder as the NuXmv executable. Then go to the terminal and change directory to this
--  folder and execute in steps:
--     (1) "./nuXmv -int Bracha-Byzantine.smv" (starts NuXmv in interactive mode with the model file)
--     (2) "go_msat" (inside the NuXmv shell, enable the IC3 engine)
--     (3) "check_ltlspec_ic3" (checks all the LTL specifications using IC3)

--==============================================================================
-- RPT SYNTAX: Bracha (Byzantine Failures), jump bound b = 1
-- The model abstracts away Validate, Reliable Broadcast primitives, 
-- and models the protocol in Fig. 4 (Bracha, 1987).:
-- https://www.sciencedirect.com/science/article/pii/089054018790054X).
-- Phase order (per round): Initial -> Ready -> Promise -> (Decide | Initial of next round)
--==============================================================================

-- Parameters:
--   P := { n, t }

-- Resilience condition:
--   rc := (n > 0) & (t >= 0) & (3*t < n)

-- Control locations (L) and initial control locations (I):
--   L := { s0, s1, i0, i1, r0, r1, p0, p1, px, d0, d1, fail } 
--   I := { s0, s1 }

-- Message types (M):
--   M := { mi0, mi1, mr0, mr1, mp0, mp1, mpx, mfi0, mfi1, mfr0, mfr1, mfp0, mfp1, mfpx }

-- Broadcast function Bcast : L -> M U { - }
--   Bcast(s0) = -
--   Bcast(s1) = -
--   Bcast(i0) = mi0
--   Bcast(i1) = mi1
--   Bcast(r0) = mr0
--   Bcast(r1) = mr1
--   Bcast(p0) = mp0
--   Bcast(p1) = mp1
--   Bcast(px) = mpx
--   Bcast(d0) = -
--   Bcast(d1) = -
--   Bcast(fail) = nondeterministically chooses a subset of message types 
--                 from { mfi0, mfi1, mfr0, mfr1, mfp0, mfp1, mfpx }, 
--                 such that exactly one of {mfi0, mfi1}, one of {mfr0, mfr1}, 
--                 and one of {mfp0, mfp1, mfpx} is broadcast, consistent with 
--                 the underlying protocol.
--                 
--                 This abstraction reflects the Validate primitive 
--                 (see Section 3 of [Bracha, 1987]: 
--                 https://www.sciencedirect.com/science/article/pii/089054018790054X).
--
--                 Note: this is a shorthand. Ideally, each choice would be 
--                 represented by a distinct control location. For brevity, we 
--                 encode this nondeterminism implicitly here rather than 
--                 expanding the state space.

-- Abbreviation:
--   Q := n - t

-- Rules:
-- Syntax:
--   [frm: <loc>, to: <loc>, guard: <LinArith(M U P)>, type: <0|1>]

-- These guards follow Bracha's original protocol, with one key adjustment: 
-- processes cannot distinguish messages from correct vs. faulty senders. 
-- Consequently, each counter mi0/mi1 is replaced by (mi0 + mfi0)/(mi1 + mfi1), 
-- and likewise for mr0/mr1 and mp0/mp1/mpx.

-- Each phase is a round and thus all rules are type = 1
  
-- Guard abbreviations:

--   g1 := ((mi0 + mfi0) + (mi1 + mfi1) >= Q) & ((mi0 + mfi0) >= (mi1 + mfi1))
--   g2 := ((mi0 + mfi0) + (mi1 + mfi1) >= Q) & ((mi1 + mfi1) >= (mi0 + mfi0))
--   g3 := ((mr0 + mfr0) + (mr1 + mfr1) >= Q) & (2*(mr0 + mfr0) > n)
--   g4 := ((mr0 + mfr0) + (mr1 + mfr1) >= Q) & (2*(mr1 + mfr1) > n)
--   g5 := ((mr0 + mfr0) + (mr1 + mfr1) >= Q) & (2*(mr0 + mfr0) <= n) & (2*(mr1 + mfr1) <= n)
--   g6 := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp0 + mfp0) > 2*t)
--   g7 := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp1 + mfp1) > 2*t)
--   g8 := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp0 + mfp0) <= 2*t) & ((mp1 + mfp1) <= 2*t) & ((mp0 + mfp0) > t)
--   g9 := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp0 + mfp0) <= 2*t) & ((mp1 + mfp1) <= 2*t) & ((mp1 + mfp1) > t)
--   g10 := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp0 + mfp0) <= t) & ((mp1 + mfp1) <= t)


-- Start -> Initial -------------------------------------------------------------
-- r1  = [frm: s0, to: i0, guard: TRUE, type: 1]
-- r2  = [frm: s1, to: i1, guard: TRUE, type: 1]

-- Initial -> Ready -------------------------------------------------------------
-- r3  = [frm: i0, to: r0, guard: g1, type: 1]
-- r4  = [frm: i1, to: r0, guard: g1, type: 1]
-- r5  = [frm: i0, to: r1, guard: g2, type: 1]
-- r6  = [frm: i1, to: r1, guard: g2, type: 1]

-- Ready -> Promise -------------------------------------------------------------
-- r7  = [frm: r0, to: p0, guard: g3, type: 1]
-- r8  = [frm: r1, to: p0, guard: g3, type: 1]
-- r9  = [frm: r0, to: p1, guard: g4, type: 1]
-- r10  = [frm: r1, to: p1, guard: g4, type: 1]
-- r11  = [frm: r0, to: px, guard: g5, type: 1]
-- r12  = [frm: r1, to: px, guard: g5, type: 1]

-- Promise -> Decide (0/1) -----------------------------------------------------
-- r13 = [frm: p0, to: d0, guard: g6, type: 1]
-- r14 = [frm: p1, to: d0, guard: g6, type: 1]
-- r15 = [frm: px, to: d0, guard: g6, type: 1]
-- r16 = [frm: p0, to: d1, guard: g7, type: 1]
-- r17 = [frm: p1, to: d1, guard: g7, type: 1]
-- r18 = [frm: px, to: d1, guard: g7, type: 1]

-- Promise -> Initial (without coin-flip) --------------------------------------
-- r19 = [frm: p0, to: i0, guard: g8, type: 1]
-- r20 = [frm: p1, to: i0, guard: g8, type: 1]
-- r21 = [frm: px, to: i0, guard: g8, type: 1]
-- r22 = [frm: p0, to: i1, guard: g9, type: 1]
-- r23 = [frm: p1, to: i1, guard: g9, type: 1]
-- r24 = [frm: px, to: i1, guard: g9, type: 1]

-- Promise -> Initial (coin-flip: non-deterministically) -----------------------
-- r25 = [frm: p0, to: i0, guard: g10, type: 1]
-- r26 = [frm: p1, to: i0, guard: g10, type: 1]
-- r27 = [frm: px, to: i0, guard: g10, type: 1]
-- r28 = [frm: p0, to: i1, guard: g10, type: 1]
-- r29 = [frm: p1, to: i1, guard: g10, type: 1]
-- r30 = [frm: px, to: i1, guard: g10, type: 1]

-- Fail -> Fail -------------------------------------------------------------
-- r31 = [frm: fail, to: fail, guard: TRUE, type: 1]

--==============================================================================
-- LTL-translated HSCL Spec: Agreement, Validity, Restricted Termination
--==============================================================================

-- We use cumulative history record counters:
--   Rd0, Rd1, Rs0, Rs1, Rfail
-- All counts are cumulative across all rounds.

-- LTL over these cumulative counters:
-- Agreement              : G(Rd0 <= 0) | G(Rd1 <= 0)
-- Validity-0             : (Rs0 <= 0) -> G(Rd0 <= 0)
-- Validity-1             : (Rs0 <= 0 -> G(Rd0 <= 0)) & (Rs1 <= 0 -> G(Rd1 <= 0))
-- Termination            : F(Rd0 + Rd1 + Rfail  > n - 1)
-- Restricted-Termination : F(Rd0 + Rd1 > 0) -> F(Rd0 + Rd1 + Rfail > n - 1)

--==============================================================================
-- The abstract semantics (RDTS^RIA)
--==============================================================================

-- The abstract semantics of the above RPT:
-- (1) Remove received-message detail (RMA); guards g1–g10 are used with their existential counterparts.
-- (2) Omit process identities (PIA) and use per-location counters.
-- (3) Strong SSR: processes jump synchronously between phases, including Byzantine faulty.
-- (4) BWA: once processes jump to the next phase, forget previous-round counters and reuse them for the new phase.
-- (5) Augment states with history record counters (Rd0, Rd1, Rs0, Rs1, Rfail) to evaluate the LTL formulas.
-- (6) RIA: abstract away the round and phase identity of the current synchronous phase.



MODULE main

-- parameter counters, they are frozen as they don’t change under transitions

FROZENVAR
  n : integer;     -- # processes 
  t : integer;     -- crash threshold


-- Per round location counters

VAR
  s0  : integer;     -- # processes starting round 0 with value 0
  s1  : integer;     -- # processes starting round 0 with value 1
  i0  : integer;     -- # processes proposing 0 
  i1  : integer;     -- # processes proposing 1 
  r0  : integer;     -- # processes ready 0 
  r1  : integer;     -- # processes ready 1 
  p0  : integer;     -- # processes promising 0
  p1  : integer;     -- # processes promising 1
  px  : integer;     -- # processes promising X (undecided)
  d0  : integer;     -- # processes decided 0 
  d1  : integer;     -- # processes decided 1 
  fail : integer;    -- # processes Byzantine faulty


-- Per round message counters

VAR
  mi0 : integer;      -- # correct broadcasts of 0 in Initial phase
  mi1 : integer;      -- # correct broadcasts of 1 in Initial phase
  mr0 : integer;      -- # correct broadcasts of 0 in Ready phase
  mr1 : integer;      -- # correct broadcasts of 1 in Ready phase
  mp0 : integer;      -- # correct broadcasts of promise-0
  mp1 : integer;      -- # correct broadcasts of promise-1
  mpx : integer;      -- # correct broadcasts of promise-X
  mfi0 : integer;     -- # faulty broadcasts of 0 in Initial phase
  mfi1 : integer;     -- # faulty broadcasts of 1 in Initial phase
  mfr0 : integer;     -- # faulty broadcasts of 0 in Ready phase
  mfr1 : integer;     -- # faulty broadcasts of 1 in Ready phase
  mfp0 : integer;     -- # faulty broadcasts of promise-0
  mfp1 : integer;     -- # faulty broadcasts of promise-1
  mfpx : integer;     -- # faulty broadcasts of promise-X  


-- History record counters

VAR
  Rs0    : integer;  -- cumulative (across all rounds) counts of # of visits to s0
  Rs1    : integer;  -- cumulative counts of # of visits to s1
  Rd0    : integer;  -- cumulative counts of # of visits to d0
  Rd1    : integer;  -- cumulative counts of # of visits to d1
  Rfail  : integer;  -- cumulative counts of Byzantine faulty processes


-- Initially:
--  (1) Parameter counters satisfy the resilience condition.
--  (2) All processes start in the initial control locations (s0, s1).
--  (3) All message counters are 0.
--  (4) History counters match the corresponding location counters.

INIT
  n > 0 & t >= 0 & 3*t < n &

  s0 >= 0 & s1 >= 0 & fail >= 0 & fail <= t & s0 + s1 + fail = n &
  i0 = 0 & i1 = 0 &
  r0 = 0 & r1 = 0 &
  p0 = 0 & p1 = 0 & px = 0 &
  d0 = 0 & d1 = 0 &

  mi0 = 0 & mi1 = 0 &
  mr0 = 0 & mr1 = 0 &
  mp0 = 0 & mp1 = 0 & mpx = 0 &
  mfi0 = 0 & mfi1 = 0 &
  mfr0 = 0 & mfr1 = 0 &
  mfp0 = 0 & mfp1 = 0 & mfpx = 0 &

  Rs0 = s0 & Rs1 = s1 & 
  Rd0 = 0 & Rd1 = 0 & 
  Rfail = fail;

-- Macro Update Transitions:
-- In each phase, the only transition is a jump to the next phase.
-- All processes perform this jump synchronously.
-- We use four macro jump transitions: 
-- Start -> Initial, Initial -> Ready, Ready -> Promise, Promise -> (Initial | Decide).

-- Before specifying transitions we define the upward closure of guards g1-g10 (see RPT syntax on top)

DEFINE Q := n - t;

DEFINE 
  g1c := ((mi0 + mfi0) + (mi1 + mfi1) >= Q) & (2*(mi0 + mfi0) >= Q);
  g2c := ((mi0 + mfi0) + (mi1 + mfi1) >= Q) & (2*(mi1 + mfi1) >= Q);
  g3c := ((mr0 + mfr0) + (mr1 + mfr1) >= Q) & (2*(mr0 + mfr0) > n);
  g4c := ((mr0 + mfr0) + (mr1 + mfr1) >= Q) & (2*(mr1 + mfr1) > n);
  g5c := ((mr0 + mfr0) + (mr1 + mfr1) >= Q) & (2*(mr0 + mfr0) >= 2*Q - n) & (2*(mr1 + mfr1) >= 2*Q - n);
  g6c := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp0 + mfp0) > 2*t);
  g7c := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp1 + mfp1) > 2*t);
  g8c := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp1 + mfp1) + (mpx + mfpx) >= Q - 2*t) & ((mp0 + mfp0) + (mpx + mfpx) >= Q - 2*t) & ((mpx + mfpx) >= Q - 4*t) & ((mp0 + mfp0) > t);
  g9c := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) & ((mp1 + mfp1) + (mpx + mfpx) >= Q - 2*t) & ((mp0 + mfp0) + (mpx + mfpx) >= Q - 2*t) & ((mpx + mfpx) >= Q - 4*t) & ((mp1 + mfp1) > t);
  g10c := ((mp0 + mfp0) + (mp1 + mfp1) + (mpx + mfpx) >= Q) &  ((mp1 + mfp1) + (mpx + mfpx) >= Q - t) & ((mp0 + mfp0) + (mpx + mfpx) >= Q - t);


TRANS
  ( -- Start -> Initial, enabled if current round is start phase i.e. s0 + s1 > 0
    s0 + s1 > 0 & 
    
    -- reset and update location counters
    next(i0) = s0 & next(i1) = s1 & next(fail) = fail &
    next(r0) = 0 & next(r1) = 0 &
    next(p0) = 0 & next(p1) = 0 & next(px) = 0 & 
    next(s0) = 0 & next(s1) = 0 &
    next(d0) = 0 & next(d1) = 0 & 

    -- reset and update message counters
    next(mi0) = next(i0) & next(mi1) = next(i1) &
    next(mr0) = 0 & next(mr1) = 0 &
    next(mp0) = 0 & next(mp1) = 0 & next(mpx) = 0 &
    
    next(mfi0) + next(mfi1) <= next(fail) &
    next(mfi0) >= 0 & next(mfi1) >= 0 &
    next(mfr0) = 0 & next(mfr1) = 0 &
    next(mfp0) = 0 & next(mfp1) = 0 & next(mfpx) = 0 &


    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 & next(Rfail) = Rfail &
    next(Rd0) = Rd0 & next(Rd1) = Rd1
    

  )
  |
  ( -- Initial -> Ready, enabled if current round is initial phase i.e. i0 + i1 > 0
    d0 + d1 + i0 + i1 > 0 &

    next(r0) >= 0 & next(r1) >= 0 & 
    next(r0) + next(r1) = i0 + i1 + d0 + d1 &
    next(fail) = fail &
    next(i0) = 0 & next(i1) = 0 & 
    next(d0) = 0 & next(d1) = 0 & 
    next(s0) = 0 & next(s1) = 0 & 
    next(p0) = 0 & next(p1) = 0 & next(px) = 0 & 

    -- if some process is moving to location l then then upward closure of some guard targeting l must hold
    ((next(r0) > 0) -> g1c) & 
    ((next(r1) > 0) -> g2c) & 

    -- reset and update message counters
    next(mr0) = next(r0) & next(mr1) = next(r1) &
    next(mi0) = 0 & next(mi1) = 0 &
    next(mp0) = 0 & next(mp1) = 0 & next(mpx) = 0 &


    next(mfr0) + next(mfr1) <= next(fail) & 
    next(mfi0) = 0 & next(mfi1) = 0 &
    next(mfr0) >= 0 & next(mfr1) >= 0 &
    next(mfp0) = 0 & next(mfp1) = 0 & next(mfpx) = 0 &

     -- faulty processes conform to the underlying protocol
    ((next(mfr0) > 0) -> g1c) & 
    ((next(mfr1) > 0) -> g2c) & 

    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 & next(Rfail) = Rfail &
    next(Rd0) = Rd0 & next(Rd1) = Rd1
    
  )
  |
  (
    -- Ready -> Promise, enabled if current round is a ready phase i.e. r0 + r1 > 0
    r0 + r1 > 0 &

    -- reset and update location counters
    next(p0) >= 0 & next(p1) >= 0 & next(px) >= 0 &
    next(p0) + next(p1) + next(px) = r0 + r1 &
    next(fail) = fail &
    next(r0) = 0 & next(r1) = 0 &
    next(i0) = 0 & next(i1) = 0 & 
    next(d0) = 0 & next(d1) = 0 & 
    next(s0) = 0 & next(s1) = 0 & 
    
    -- if some process is moving to location l then then upward closure of some guard targeting l must hold
    ((next(p0) > 0) -> g3c) & 
    ((next(p1) > 0) -> g4c) & 
    ((next(px) > 0) -> g5c) &

    -- reset and update message counters
    next(mp0) = next(p0) & next(mp1) = next(p1) & next(mpx) = next(px) & 
    next(mr0) = 0 & next(mr1) = 0 &
    next(mi0) = 0 & next(mi1) = 0 &

    next(mfp0) + next(mfp1) + next(mfpx) <= next(fail) &
    next(mfi0) = 0 & next(mfi1) = 0 &
    next(mfr0) = 0 & next(mfr1) = 0 &
    next(mfp0) >= 0 & next(mfp1) >= 0 & next(mfpx) >= 0 &

     -- faulty processes conform to the underlying protocol
    ((next(mfp0) > 0) -> g3c) & 
    ((next(mfp1) > 0) -> g4c) & 
    ((next(mfpx) > 0) -> g5c) &

    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 & next(Rfail) = Rfail &
    next(Rd0) = Rd0 & next(Rd1) = Rd1

  )
  | 
  ( -- Promise -> Initial/Decide, enabled if current round is a promise phase i.e. p0 + p1 + px > 0
    p0 + p1 + px > 0 &

    -- reset and update location counters
    next(d0) + next(d1) + next(i0) + next(i1) = p0 + p1 + px &
    next(d0) >= 0 & next(d1) >= 0 & next(i0) >= 0 & next(i1) >= 0 &
    next(fail) = fail &
    next(r0) = 0 & next(r1) = 0 &
    next(p0) = 0 & next(p1) = 0 & next(px) = 0 & 
    next(s0) = 0 & next(s1) = 0 &

    -- if some process is moving to location l then then upward closure of some guard targeting l must hold
    ((next(d0) > 0) -> g6c) & 
    ((next(d1) > 0) -> g7c) & 
    ((next(i0) > 0) -> (g8c | g10c)) & 
    ((next(i1) > 0) -> (g9c | g10c)) &

    -- reset and update message counters
    next(mi0) = next(i0) + next(d0) & next(mi1) = next(i1) + next(d1) &
    next(mp0) = 0 & next(mp1) = 0 & next(mpx) = 0 &

    next(mfi0) + next(mfi1) <= next(fail) & 
    next(mfi0) >= 0 & next(mfi1) >= 0 &
    next(mfr0) = 0 & next(mfr1) = 0 &
    next(mfp0) = 0 & next(mfp1) = 0 & next(mfpx) = 0 &

     -- faulty processes conform to the underlying protocol
    ((next(mfi0) > 0) -> (g8c | g10c)) & 
    ((next(mfi1) > 0) -> (g9c | g10c)) &

    -- update record counters
    next(Rs0) = Rs0 & next(Rs1) = Rs1 & next(Rfail) = Rfail & 
    next(Rd0) = Rd0 + next(d0) & next(Rd1) = Rd1 + next(d1)

  );

-- LTL Specifications

-- Agreement
LTLSPEC G(Rd0 <= 0) | G(Rd1 <= 0); 

-- Validity
LTLSPEC (Rs0 <= 0 -> G(Rd0 <= 0)) & (Rs1 <= 0 -> G(Rd1 <= 0));

-- Restricted-Termination
LTLSPEC F(Rd0 + Rd1 > 0) -> F(Rd0 + Rd1 + Rfail  > n - 1);

-- Termination -- Not satisfied and outputs counterexample
LTLSPEC (F(Rd0 + Rd1 + Rfail  > n - 1));